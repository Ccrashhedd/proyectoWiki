---
---

<article class="article">
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ol class="breadcrumb-list">
            <li><a href="/">Inicio</a></li>
            <li><a href="#">Testing</a></li>
            <li><span>Pruebas de integración</span></li>
        </ol>
    </nav>

    <header class="article-header">
        <div class="badge-group">
            <span class="badge badge-primary">Intermedio</span>
        </div>
        <h1 class="article-title">Pruebas de Integración</h1>
        <p class="article-description">
            Aprende cómo verificar la interacción entre diferentes módulos o componentes del sistema 
            para comprobar que trabajen de forma coherente y correcta al combinarse.
        </p>
        <div class="article-meta">
            <time datetime="2025-10-20">Última actualización: 20 de octubre, 2025</time>
            <span class="reading-time">8 min de lectura</span>
        </div>
    </header>

    <div class="article-content">
        <section id="definicion">
            <h2>Definición</h2>
            <p>0 que se encarga de verificar cómo los diferentes 
                módulos o componentes del sistema interactúan entre sí. Su objetivo es comprobar que trabajen 
                de forma coherente y correcta al combinarse.
            </p>
        </section>

        <section id="objetivos">
            <h2>Objetivos Principales</h2>
            <ul>
                <li><strong>Detectar errores en las interfaces:</strong> Identificar problemas en la comunicación entre módulos.</li>
                <li><strong>Verificar la transferencia de datos:</strong> Asegurar que los datos fluyan correctamente entre componentes.</li>
                <li><strong>Validar el flujo de control:</strong> Comprobar que el sistema ejecute las operaciones en el orden correcto.</li>
                <li><strong>Garantizar el cumplimiento funcional:</strong> Confirmar que el sistema integrado cumpla con los requisitos especificados.</li>
            </ul>
        </section>

        <section id="tipos-integracion">
            <h2>Tipos de Integración</h2>
            
            <h3>Big Bang</h3>
            <p>
                Todos los módulos se integran al mismo tiempo. Es una estrategia rápida de implementar 
                pero difícil de depurar cuando surgen errores.
            </p>
            <p><strong>Ventajas:</strong> Rápida implementación, menor esfuerzo inicial.</p>
            <p><strong>Desventajas:</strong> Difícil localizar errores, alto riesgo de fallas críticas.</p>

            <h3>Incremental</h3>
            <p>
                Los módulos se integran poco a poco, permitiendo detectar y corregir errores de manera progresiva.
            </p>
            
            <h4>Estrategias Incrementales:</h4>
            <ul>
                <li><strong>Ascendente (Bottom-Up):</strong> Se inicia con los módulos de bajo nivel y se van integrando hacia arriba. 
                Requiere el uso de drivers para simular módulos superiores.</li>
                <li><strong>Descendente (Top-Down):</strong> Se inicia con los módulos principales y se van integrando los subordinados. 
                Requiere el uso de stubs para simular módulos inferiores.</li>
                <li><strong>Mixta o Sandwich:</strong> Combina las estrategias ascendente y descendente, permitiendo integrar 
                simultáneamente desde varios puntos.</li>
            </ul>
        </section>

        <section id="proceso">
            <h2>Proceso de Pruebas de Integración</h2>
            <ol>
                <li><strong>Seleccionar módulos:</strong> Identificar qué componentes se van a integrar en cada iteración.</li>
                <li><strong>Diseñar casos de prueba:</strong> Crear escenarios que evalúen la comunicación entre módulos.</li>
                <li><strong>Usar stubs y drivers:</strong> Implementar componentes simulados para reemplazar módulos faltantes.</li>
                <li><strong>Ejecutar las pruebas:</strong> Correr los casos de prueba y monitorear el comportamiento del sistema.</li>
                <li><strong>Registrar resultados:</strong> Documentar los errores encontrados y las métricas obtenidas.</li>
                <li><strong>Corregir y repetir:</strong> Solucionar los problemas detectados y volver a ejecutar las pruebas hasta completar la integración.</li>
            </ol>
        </section>

        <section id="herramientas">
            <h2>Stubs y Drivers</h2>
            <p><strong>Stubs:</strong> Son módulos simulados que reemplazan componentes subordinados que aún no están disponibles. 
            Proporcionan respuestas predefinidas para permitir la prueba de módulos superiores.</p>
            <p><strong>Drivers:</strong> Son módulos simulados que actúan como invocadores de módulos de bajo nivel que aún no 
            tienen sus controladores superiores implementados.</p>
        </section>

        <section id="ejemplo">
            <h2>Ejemplo Práctico</h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-lang">javascript</span>
                    <button class="code-copy">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        Copiar
                    </button>
                </div>
                <pre class="code-content"><code>{`// Prueba de integración entre módulo de API y base de datos
describe('Integración API - Database', () => {
  it('debe guardar y recuperar datos del usuario', async () => {
    // Crear usuario a través de la API
    const newUser = await api.createUser({
      name: 'Juan Pérez',
      email: 'juan@example.com'
    });
    
    // Verificar que se guardó correctamente
    expect(newUser.id).toBeDefined();
    expect(newUser.name).toBe('Juan Pérez');
    
    // Recuperar usuario desde la base de datos
    const retrievedUser = await api.getUser(newUser.id);
    
    // Verificar que los datos coinciden
    expect(retrievedUser.email).toBe('juan@example.com');
    expect(retrievedUser.name).toBe('Juan Pérez');
  });

  it('debe manejar errores de conexión', async () => {
    // Simular falla en la base de datos
    await expect(api.getUserWithBrokenDB(123))
      .rejects.toThrow('Database connection failed');
  });
});`}</code></pre>
            </div>
        </section>

        <section id="importancia">
            <h2>Importancia de las Pruebas de Integración</h2>
            <ul>
                <li><strong>Detecta errores de interacción:</strong> Identifica problemas que no son visibles en pruebas unitarias.</li>
                <li><strong>Asegura cohesión del sistema:</strong> Garantiza que los módulos funcionen correctamente en conjunto.</li>
                <li><strong>Mejora la estabilidad:</strong> Reduce la probabilidad de fallas en las pruebas de sistema.</li>
                <li><strong>Valida la arquitectura:</strong> Permite verificar que el diseño y las dependencias del software sean correctos.</li>
                <li><strong>Reduce costos:</strong> Detectar errores en esta fase es más económico que en producción.</li>
            </ul>
        </section>
    </div>

    <footer class="article-footer">
        <div class="feedback">
            <p class="feedback-title">¿Te fue útil esta página?</p>
            <div class="feedback-buttons">
                <button class="feedback-button">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                    </svg>
                    Sí
                </button>
                <button class="feedback-button">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
                    </svg>
                    No
                </button>
            </div>
        </div>
    </footer>
</article>